interface YouTubeAPIConfig {
  apiKey: string;
}

export interface YouTubeVideoItem {
  id: {
    videoId: string;
  };
  snippet: {
    title: string;
    description: string;
    channelTitle: string;
    channelId: string;
    publishedAt: string;
    thumbnails: {
      default: {
        url: string;
      };
    };
    tags?: string[];
    categoryId?: string;
  };
}

interface YouTubeVideoDetails {
  id: string;
  statistics: {
    viewCount: string;
    likeCount?: string;
    commentCount?: string;
  };
  contentDetails: {
    duration: string;
    definition: string;
    caption: string;
  };
  snippet: {
    channelId: string;
    publishedAt: string;
    title: string;
  };
}

interface YouTubeChannelDetails {
  id: string;
  statistics: {
    subscriberCount: string;
  };
}

export interface PrioritizedVideo {
  videoId: string;
  title: string;
  channelTitle: string;
  publishedAt: string;
  viewCount: number;
  duration: number; // seconds
  subscriberCount?: number;
  priority: number;
}

export interface SubtitleTrack {
  language: string;
  text: string;
  isAutoGenerated: boolean;
}

interface YouTubeSearchResponse {
  items: YouTubeVideoItem[];
  pageInfo: {
    totalResults: number;
    resultsPerPage: number;
  };
}

export class YouTubeAPI {
  private config: YouTubeAPIConfig | null = null;
  
  // ìë§‰ ì¶”ì¶œ ë¹ˆë„ ì œì–´ë¥¼ ìœ„í•œ ëŒ€ê¸° ì‹œê°„ ê´€ë¦¬
  private lastSubtitleRequest: number = 0;
  private subtitleDelayMs: number = 5000; // ê¸°ë³¸ 5ì´ˆ (ì¦ê°€)
  private maxDelayMs: number = 60000; // ìµœëŒ€ 60ì´ˆ (ì¦ê°€)
  private consecutiveErrors: number = 0;

  async loadConfig(): Promise<void> {
    try {
      // YouTube API ì„¤ì •ì„ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ë‚˜ Electron ì„¤ì •ì—ì„œ ë¡œë“œ
      if ((window as any).electronAPI && typeof (window as any).electronAPI.loadYouTubeApiSettings === 'function') {
        const result = await (window as any).electronAPI.loadYouTubeApiSettings();
        if (result && result.success && result.data) {
          this.config = {
            apiKey: result.data.apiKey
          };
          console.log('âœ… YouTube API ì„¤ì • ë¡œë“œ ì„±ê³µ');
        } else {
          console.warn('âš ï¸ YouTube API ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤');
        }
      } else {
        console.warn('âš ï¸ Electron APIê°€ ì—†ìŠµë‹ˆë‹¤ (ë¸Œë¼ìš°ì € í™˜ê²½)');
      }
    } catch (error) {
      console.error('âŒ YouTube API ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', error);
      throw new Error(`YouTube API ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
    }
  }

  async searchVideos(keyword: string, maxResults = 10): Promise<YouTubeVideoItem[]> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. loadConfig()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì„¸ìš”.');
    }

    try {
      const encodedKeyword = encodeURIComponent(keyword);
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}&order=relevance`;

      console.log(`ğŸ“º YouTube API ê²€ìƒ‰: ${keyword} (ìµœëŒ€ ${maxResults}ê°œ)`);

      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error('YouTube API í• ë‹¹ëŸ‰ ì´ˆê³¼ ë˜ëŠ” API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        } else if (response.status === 400) {
          throw new Error('YouTube API ìš”ì²­ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
          throw new Error(`YouTube API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${response.statusText}`);
        }
      }

      const data: YouTubeSearchResponse = await response.json();
      
      console.log(`âœ… YouTube ê²€ìƒ‰ ì™„ë£Œ: ${data.items.length}ê°œ ë™ì˜ìƒ`);
      
      return data.items;

    } catch (error) {
      console.error('âŒ YouTube ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  async getVideoDetails(videoId: string): Promise<any> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
    }

    try {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails&id=${videoId}&key=${this.config.apiKey}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`YouTube API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status}`);
      }

      const data = await response.json();
      return data.items[0];

    } catch (error) {
      console.error('âŒ YouTube ë™ì˜ìƒ ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // ISO 8601 durationì„ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ ë³€í™˜
  static parseDuration(duration: string): string {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return '0:00';

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  // ì¡°íšŒìˆ˜ë¥¼ í•œêµ­ì–´ í˜•íƒœë¡œ ë³€í™˜
  static formatViewCount(viewCount: string): string {
    const count = parseInt(viewCount);
    if (count >= 10000) {
      return `${Math.floor(count / 10000)}ë§ŒíšŒ`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}ì²œíšŒ`;
    } else {
      return `${count}íšŒ`;
    }
  }

  // ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë™ì˜ìƒ ê²€ìƒ‰ ë° ì„ ë³„
  async searchPrioritizedVideos(keyword: string, maxResults = 10): Promise<PrioritizedVideo[]> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. loadConfig()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì„¸ìš”.');
    }

    try {
      console.log(`ğŸ¯ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ YouTube ê²€ìƒ‰: ${keyword}`);

      // 1. ê¸°ë³¸ ê²€ìƒ‰ (ë” ë§ì€ ê²°ê³¼ë¥¼ ê°€ì ¸ì™€ì„œ í•„í„°ë§)
      const searchResults = await this.searchVideosWithFilters(keyword, maxResults);
      
      if (searchResults.length === 0) {
        console.warn('ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤');
        return [];
      }

      // 2. ë™ì˜ìƒ ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë°°ì¹˜ ì²˜ë¦¬)
      const videoIds = searchResults.map(video => video.id.videoId);
      const videoDetails = await this.getMultipleVideoDetails(videoIds);
      
      // 3. ì±„ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë°°ì¹˜ ì²˜ë¦¬)
      const channelIds = [...new Set(searchResults.map(video => video.snippet.channelId))];
      const channelDetails = await this.getMultipleChannelDetails(channelIds);

      // 4. ìš°ì„ ìˆœìœ„ ê³„ì‚° ë° ì •ë ¬
      const prioritizedVideos: PrioritizedVideo[] = [];

      for (const video of searchResults) {
        const details = videoDetails.find(d => d.id === video.id.videoId);
        const channel = channelDetails.find(c => c.id === video.snippet.channelId);
        
        if (!details) continue;

        const prioritizedVideo: PrioritizedVideo = {
          videoId: video.id.videoId,
          title: video.snippet.title,
          channelTitle: video.snippet.channelTitle,
          publishedAt: video.snippet.publishedAt,
          viewCount: parseInt(details.statistics.viewCount || '0'),
          duration: this.parseDurationToSeconds(details.contentDetails.duration),
          subscriberCount: channel ? parseInt(channel.statistics.subscriberCount || '0') : 0,
          priority: 0,
          // ì¶”ê°€ ë°ì´í„°
          likeCount: details.statistics.likeCount || 'N/A',
          commentCount: details.statistics.commentCount || 'N/A'
        } as PrioritizedVideo & { likeCount: string; commentCount: string };

        // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
        prioritizedVideo.priority = this.calculatePriority(prioritizedVideo);
        
        // ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
        if (this.passesBasicFilters(prioritizedVideo)) {
          prioritizedVideos.push(prioritizedVideo);
        }
      }

      // 5. ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ í›„ ìƒìœ„ Nê°œ ë°˜í™˜
      const sortedVideos = prioritizedVideos
        .sort((a, b) => b.priority - a.priority)
        .slice(0, maxResults);

      console.log(`âœ… ìš°ì„ ìˆœìœ„ ë¶„ì„ ì™„ë£Œ: ${sortedVideos.length}ê°œ ë™ì˜ìƒ ì„ ë³„`);
      return sortedVideos;

    } catch (error) {
      console.error('âŒ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // í•„í„°ê°€ ì ìš©ëœ ê²€ìƒ‰
  private async searchVideosWithFilters(keyword: string, maxResults: number): Promise<YouTubeVideoItem[]> {
    const encodedKeyword = encodeURIComponent(keyword);

    const url = `https://www.googleapis.com/youtube/v3/search?` +
      `part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}` +
      `&order=relevance&videoDuration=medium&videoCaption=any`;

    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`YouTube API ê²€ìƒ‰ ì‹¤íŒ¨: ${response.status}`);
    }

    const data: YouTubeSearchResponse = await response.json();
    return data.items;
  }

  // ì—¬ëŸ¬ ë™ì˜ìƒì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ê°€ì ¸ì˜¤ê¸°
  private async getMultipleVideoDetails(videoIds: string[]): Promise<YouTubeVideoDetails[]> {
    if (videoIds.length === 0) return [];

    const batchSize = 50; // YouTube API ì œí•œ
    const results: YouTubeVideoDetails[] = [];

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/videos?` +
        `part=statistics,contentDetails,snippet&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // ì—¬ëŸ¬ ì±„ë„ì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ê°€ì ¸ì˜¤ê¸°
  private async getMultipleChannelDetails(channelIds: string[]): Promise<YouTubeChannelDetails[]> {
    if (channelIds.length === 0) return [];

    const batchSize = 50;
    const results: YouTubeChannelDetails[] = [];

    for (let i = 0; i < channelIds.length; i += batchSize) {
      const batch = channelIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/channels?` +
        `part=statistics&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚° (ë¸”ë¡œê·¸ ì‘ì„± ì°¸ê³ ìš© ì½˜í…ì¸  ì„ ë³„)
  private calculatePriority(video: PrioritizedVideo): number {
    let score = 0;

    // 1. ì¡°íšŒìˆ˜ ì ìˆ˜ (35%) - ë§ì€ ì‚¬ëŒì´ ë³¸ = ìœ ìš©í•œ ì •ë³´ì¼ ê°€ëŠ¥ì„±
    if (video.viewCount > 1000000) score += 35;
    else if (video.viewCount > 500000) score += 30;
    else if (video.viewCount > 100000) score += 25;
    else if (video.viewCount > 50000) score += 20;
    else if (video.viewCount > 10000) score += 15;
    else if (video.viewCount > 1000) score += 10;

    // 2. ì˜ìƒ ê¸¸ì´ ì ìˆ˜ (30%) - ì ì ˆí•œ ê¸¸ì´ = ì¶©ë¶„í•œ ì •ë³´ëŸ‰
    if (video.duration >= 600 && video.duration <= 1200) score += 30; // 10-20ë¶„ (ìµœì )
    else if (video.duration >= 300 && video.duration <= 1800) score += 25; // 5-30ë¶„
    else if (video.duration >= 180 && video.duration <= 1800) score += 20; // 3-30ë¶„
    else if (video.duration >= 120 && video.duration <= 1800) score += 15; // 2-30ë¶„

    // 3. ì±„ë„ ì‹ ë¢°ì„± ì ìˆ˜ (25%) - ì „ë¬¸ì„±ê³¼ ì‹ ë¢°ë„
    if (video.subscriberCount && video.subscriberCount > 1000000) score += 25;
    else if (video.subscriberCount && video.subscriberCount > 500000) score += 22;
    else if (video.subscriberCount && video.subscriberCount > 100000) score += 18;
    else if (video.subscriberCount && video.subscriberCount > 50000) score += 15;
    else if (video.subscriberCount && video.subscriberCount > 10000) score += 12;
    else if (video.subscriberCount && video.subscriberCount > 1000) score += 8;

    // 4. ì—…ë¡œë“œ ë‚ ì§œ ì ìˆ˜ (10%) - ë„ˆë¬´ ì˜¤ë˜ë˜ì§€ ì•Šì€ ì •ë³´ ì„ í˜¸í•˜ë˜ í° ë¹„ì¤‘ X
    const daysSince = (Date.now() - new Date(video.publishedAt).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 365) score += 10;        // 1ë…„ ì´ë‚´
    else if (daysSince < 365 * 2) score += 8; // 2ë…„ ì´ë‚´
    else if (daysSince < 365 * 3) score += 6; // 3ë…„ ì´ë‚´
    else if (daysSince < 365 * 5) score += 4; // 5ë…„ ì´ë‚´
    else score += 2; // 5ë…„ ì´ìƒë„ ì¢‹ì€ ì •ë³´ì¼ ìˆ˜ ìˆìŒ

    return score;
  }

  // ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
  private passesBasicFilters(video: PrioritizedVideo): boolean {
    // ìµœì†Œ ì¡°ê±´ë“¤
    if (video.viewCount < 100) return false; // ìµœì†Œ ì¡°íšŒìˆ˜
    if (video.duration < 60) return false;   // ìµœì†Œ 1ë¶„
    if (video.duration > 1800) return false; // ìµœëŒ€ 30ë¶„
    

    return true;
  }

  // ISO 8601 durationì„ ì´ˆë¡œ ë³€í™˜
  private parseDurationToSeconds(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    return hours * 3600 + minutes * 60 + seconds;
  }


  // Google ì°¨ë‹¨ ê°ì§€ í•¨ìˆ˜
  private isGoogleBlocked(message: string): boolean {
    const blockedKeywords = [
      'automated queries',
      'Sorry...',
      'We\'re sorry',
      'protect our users',
      "can't process your request",
      'network may be sending',
      'verdana, arial, sans-serif',
      'GoogleSorry',
      'Google Help for more information',
      'Google Home'
    ];
    
    return blockedKeywords.some(keyword => 
      message.toLowerCase().includes(keyword.toLowerCase())
    );
  }

  // ëŒ€ê¸° ì‹œê°„ ê³„ì‚° (ì—ëŸ¬ íšŸìˆ˜ì— ë”°ë¼ ì§€ìˆ˜ì  ì¦ê°€)
  private calculateDelay(): number {
    if (this.consecutiveErrors === 0) {
      return this.subtitleDelayMs; // ê¸°ë³¸ 5ì´ˆ
    }
    
    // ì§€ìˆ˜ì  ë°±ì˜¤í”„: 5ì´ˆ -> 10ì´ˆ -> 20ì´ˆ -> 40ì´ˆ -> 60ì´ˆ(ìµœëŒ€) + ëœë¤ ì§€í„°
    const baseDelay = this.subtitleDelayMs * Math.pow(2, this.consecutiveErrors);
    const jitter = Math.random() * 2000; // 0~2ì´ˆ ëœë¤ ì¶”ê°€
    const delayWithJitter = baseDelay + jitter;
    return Math.min(delayWithJitter, this.maxDelayMs);
  }

  // ìš”ì²­ ì „ ëŒ€ê¸° ì²˜ë¦¬
  private async waitBeforeRequest(): Promise<void> {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastSubtitleRequest;
    const requiredDelay = this.calculateDelay();
    
    if (timeSinceLastRequest < requiredDelay) {
      const waitTime = requiredDelay - timeSinceLastRequest;
      console.log(`â³ Google ì°¨ë‹¨ ë°©ì§€ë¥¼ ìœ„í•´ ${Math.round(waitTime / 1000)}ì´ˆ ëŒ€ê¸°... (ì—ëŸ¬ íšŸìˆ˜: ${this.consecutiveErrors})`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    this.lastSubtitleRequest = Date.now();
  }

  // IPCë¥¼ í†µí•œ ìë§‰ ì¶”ì¶œ (ë©”ì¸ í”„ë¡œì„¸ìŠ¤ì—ì„œ ì‹¤í–‰)
  private async fetchSubtitleText(videoId: string, language?: string): Promise<string> {
    // ìš”ì²­ ì „ ëŒ€ê¸° ì²˜ë¦¬
    await this.waitBeforeRequest();
    
    try {
      console.log(`ğŸ” [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ìš”ì²­: ${videoId} (ì–¸ì–´: ${language || 'ko'})`);
      
      // ë©”ì¸ í”„ë¡œì„¸ìŠ¤ë¡œ ìë§‰ ì¶”ì¶œ ìš”ì²­
      const result = await (window as any).electronAPI.extractYouTubeSubtitles(videoId, language || 'ko');
      
      if (result.success && result.data) {
        console.log(`âœ… [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${result.data.length}ì`);
        this.consecutiveErrors = 0; // ì„±ê³µ ì‹œ ì—ëŸ¬ ì¹´ìš´í„° ë¦¬ì…‹
        return result.data.text;
      } else {
        // ì‹¤íŒ¨ ë©”ì‹œì§€ì—ì„œ Google ì°¨ë‹¨ ê°ì§€
        if (this.isGoogleBlocked(result.message || '')) {
          this.consecutiveErrors++;
          console.error(`âŒ Google ì°¨ë‹¨ ê°ì§€! ì—ëŸ¬ íšŸìˆ˜: ${this.consecutiveErrors}, ë‹¤ìŒ ëŒ€ê¸° ì‹œê°„: ${Math.round(this.calculateDelay() / 1000)}ì´ˆ`);
          throw new Error(`Googleì—ì„œ ìë™í™” ìš”ì²­ì„ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`);
        }
        
        console.error(`âŒ [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${result.message}`);
        return '';
      }

    } catch (error) {
      // Google ì°¨ë‹¨ ì˜ˆì™¸ê°€ ì•„ë‹Œ ì¼ë°˜ ì˜¤ë¥˜ì¸ ê²½ìš°ë§Œ ë¡œê·¸
      if (!(error instanceof Error && this.isGoogleBlocked(error.message))) {
        console.error(`âŒ [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ì‹œìŠ¤í…œ ì˜¤ë¥˜ (${videoId}):`, error);
      }
      throw error; // ì—ëŸ¬ë¥¼ ë‹¤ì‹œ ë˜ì ¸ì„œ ìƒìœ„ì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡
    }
  }



  // ê°„ë‹¨í•œ ìë§‰ ì¶”ì¶œ (300ì ì´ìƒë§Œ í†µê³¼) - ì¬ì‹œë„ ë¡œì§ ì ìš©
  async extractSubtitlesSimple(videoId: string, maxRetries: number = 3): Promise<SubtitleTrack[]> {
    let retryCount = 0;
    
    while (retryCount <= maxRetries) {
      try {
        console.log(`ğŸ¬ extractSubtitlesSimple ì‹œì‘: ${videoId} (ì‹œë„ ${retryCount + 1}/${maxRetries + 1})`);
        
        // ìë§‰ ì¶”ì¶œ ì‹œë„ (ëŒ€ê¸° ì‹œê°„ í¬í•¨)
        await this.waitBeforeRequest();
        const result = await (window as any).electronAPI.extractYouTubeSubtitles(videoId, 'ko');
        
        if (result.success && result.data && result.data.text) {
          console.log(`âœ… IPC ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${result.data.language} ${result.data.length}ì`);
          this.consecutiveErrors = 0; // ì„±ê³µ ì‹œ ì—ëŸ¬ ì¹´ìš´í„° ë¦¬ì…‹
          return [{
            language: result.data.language,
            text: result.data.text,
            isAutoGenerated: result.data.isAutoGenerated || true
          }];
        } else {
          // Google ì°¨ë‹¨ ê°ì§€
          if (this.isGoogleBlocked(result.message || '')) {
            this.consecutiveErrors++;
            const waitTime = this.calculateDelay();
            console.warn(`âš ï¸ Google ì°¨ë‹¨ ê°ì§€ (${retryCount + 1}/${maxRetries + 1}): ${Math.round(waitTime / 1000)}ì´ˆ í›„ ì¬ì‹œë„...`);
            
            if (retryCount < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, waitTime));
              retryCount++;
              continue;
            } else {
              console.error(`âŒ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼. Google ì°¨ë‹¨ìœ¼ë¡œ ì¸í•´ ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${videoId}`);
              return [];
            }
          } else {
            console.warn(`âš ï¸ IPC ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${result.message}`);
            return [];
          }
        }

      } catch (error) {
        // Google ì°¨ë‹¨ ì—ëŸ¬ì¸ ê²½ìš°
        if (error instanceof Error && this.isGoogleBlocked(error.message)) {
          this.consecutiveErrors++;
          const waitTime = this.calculateDelay();
          console.warn(`âš ï¸ Google ì°¨ë‹¨ ì˜ˆì™¸ ê°ì§€ (${retryCount + 1}/${maxRetries + 1}): ${Math.round(waitTime / 1000)}ì´ˆ í›„ ì¬ì‹œë„...`);
          
          if (retryCount < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, waitTime));
            retryCount++;
            continue;
          } else {
            console.error(`âŒ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼. Google ì°¨ë‹¨ìœ¼ë¡œ ì¸í•´ ìë§‰ ì¶”ì¶œ ì™„ì „ ì‹¤íŒ¨: ${videoId}`);
            return [];
          }
        } else {
          // ì¼ë°˜ì ì¸ ì—ëŸ¬
          console.error(`ğŸ’¥ extractSubtitlesSimple ì‹œìŠ¤í…œ ì˜¤ë¥˜: ${videoId}`, error);
          return [];
        }
      }
    }
    
    return [];
  }
  
  // ìë§‰ ì¶”ì¶œ ìƒíƒœ ë¦¬ì…‹ (ìˆ˜ë™ ë¦¬ì…‹ìš©)
  resetSubtitleState(): void {
    this.consecutiveErrors = 0;
    this.subtitleDelayMs = 3000;
    console.log('ğŸ”„ ìë§‰ ì¶”ì¶œ ìƒíƒœ ë¦¬ì…‹ ì™„ë£Œ');
  }
  
  // í˜„ì¬ ìë§‰ ì¶”ì¶œ ìƒíƒœ ì •ë³´ ë°˜í™˜
  getSubtitleState(): { consecutiveErrors: number; currentDelay: number; maxDelay: number } {
    return {
      consecutiveErrors: this.consecutiveErrors,
      currentDelay: this.calculateDelay(),
      maxDelay: this.maxDelayMs
    };
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const youtubeAPI = new YouTubeAPI();