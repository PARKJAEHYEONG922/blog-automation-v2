interface YouTubeAPIConfig {
  apiKey: string;
}

export interface YouTubeVideoItem {
  id: {
    videoId: string;
  };
  snippet: {
    title: string;
    description: string;
    channelTitle: string;
    channelId: string;
    publishedAt: string;
    thumbnails: {
      default: {
        url: string;
      };
    };
    tags?: string[];
    categoryId?: string;
  };
}

interface YouTubeVideoDetails {
  id: string;
  statistics: {
    viewCount: string;
    likeCount?: string;
    commentCount?: string;
  };
  contentDetails: {
    duration: string;
    definition: string;
    caption: string;
  };
  snippet: {
    channelId: string;
    publishedAt: string;
    title: string;
  };
}

interface YouTubeChannelDetails {
  id: string;
  statistics: {
    subscriberCount: string;
  };
}

export interface PrioritizedVideo {
  videoId: string;
  title: string;
  channelTitle: string;
  publishedAt: string;
  viewCount: number;
  duration: number; // seconds
  subscriberCount?: number;
  priority: number;
}

export interface SubtitleTrack {
  language: string;
  text: string;
  isAutoGenerated: boolean;
}

interface YouTubeSearchResponse {
  items: YouTubeVideoItem[];
  pageInfo: {
    totalResults: number;
    resultsPerPage: number;
  };
}

export class YouTubeAPI {
  private config: YouTubeAPIConfig | null = null;
  
  // 자막 추출 빈도 제어를 위한 대기 시간 관리
  private lastSubtitleRequest: number = 0;
  private subtitleDelayMs: number = 5000; // 기본 5초 (증가)
  private maxDelayMs: number = 60000; // 최대 60초 (증가)
  private consecutiveErrors: number = 0;

  async loadConfig(): Promise<void> {
    try {
      // YouTube API 설정을 로컬스토리지나 Electron 설정에서 로드
      if ((window as any).electronAPI && typeof (window as any).electronAPI.loadYouTubeApiSettings === 'function') {
        const result = await (window as any).electronAPI.loadYouTubeApiSettings();
        if (result && result.success && result.data) {
          this.config = {
            apiKey: result.data.apiKey
          };
          console.log('✅ YouTube API 설정 로드 성공');
        } else {
          console.warn('⚠️ YouTube API 설정이 없습니다');
        }
      } else {
        console.warn('⚠️ Electron API가 없습니다 (브라우저 환경)');
      }
    } catch (error) {
      console.error('❌ YouTube API 설정 로드 실패:', error);
      throw new Error(`YouTube API 설정 로드 실패: ${error.message}`);
    }
  }

  async searchVideos(keyword: string, maxResults = 10): Promise<YouTubeVideoItem[]> {
    if (!this.config) {
      throw new Error('YouTube API 설정이 로드되지 않았습니다. loadConfig()를 먼저 호출하세요.');
    }

    try {
      const encodedKeyword = encodeURIComponent(keyword);
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}&order=relevance`;

      console.log(`📺 YouTube API 검색: ${keyword} (최대 ${maxResults}개)`);

      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error('YouTube API 할당량 초과 또는 API 키가 유효하지 않습니다');
        } else if (response.status === 400) {
          throw new Error('YouTube API 요청 형식이 잘못되었습니다');
        } else {
          throw new Error(`YouTube API 호출 실패: ${response.status} ${response.statusText}`);
        }
      }

      const data: YouTubeSearchResponse = await response.json();
      
      console.log(`✅ YouTube 검색 완료: ${data.items.length}개 동영상`);
      
      return data.items;

    } catch (error) {
      console.error('❌ YouTube 검색 실패:', error);
      throw error;
    }
  }

  async getVideoDetails(videoId: string): Promise<any> {
    if (!this.config) {
      throw new Error('YouTube API 설정이 로드되지 않았습니다');
    }

    try {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails&id=${videoId}&key=${this.config.apiKey}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`YouTube API 호출 실패: ${response.status}`);
      }

      const data = await response.json();
      return data.items[0];

    } catch (error) {
      console.error('❌ YouTube 동영상 상세 정보 조회 실패:', error);
      throw error;
    }
  }

  // ISO 8601 duration을 사람이 읽기 쉬운 형태로 변환
  static parseDuration(duration: string): string {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return '0:00';

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  // 조회수를 한국어 형태로 변환
  static formatViewCount(viewCount: string): string {
    const count = parseInt(viewCount);
    if (count >= 10000) {
      return `${Math.floor(count / 10000)}만회`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}천회`;
    } else {
      return `${count}회`;
    }
  }

  // 우선순위 기반 동영상 검색 및 선별
  async searchPrioritizedVideos(keyword: string, maxResults = 10): Promise<PrioritizedVideo[]> {
    if (!this.config) {
      throw new Error('YouTube API 설정이 로드되지 않았습니다. loadConfig()를 먼저 호출하세요.');
    }

    try {
      console.log(`🎯 우선순위 기반 YouTube 검색: ${keyword}`);

      // 1. 기본 검색 (더 많은 결과를 가져와서 필터링)
      const searchResults = await this.searchVideosWithFilters(keyword, maxResults);
      
      if (searchResults.length === 0) {
        console.warn('검색 결과가 없습니다');
        return [];
      }

      // 2. 동영상 상세 정보 가져오기 (배치 처리)
      const videoIds = searchResults.map(video => video.id.videoId);
      const videoDetails = await this.getMultipleVideoDetails(videoIds);
      
      // 3. 채널 정보 가져오기 (배치 처리)
      const channelIds = [...new Set(searchResults.map(video => video.snippet.channelId))];
      const channelDetails = await this.getMultipleChannelDetails(channelIds);

      // 4. 우선순위 계산 및 정렬
      const prioritizedVideos: PrioritizedVideo[] = [];

      for (const video of searchResults) {
        const details = videoDetails.find(d => d.id === video.id.videoId);
        const channel = channelDetails.find(c => c.id === video.snippet.channelId);
        
        if (!details) continue;

        const prioritizedVideo: PrioritizedVideo = {
          videoId: video.id.videoId,
          title: video.snippet.title,
          channelTitle: video.snippet.channelTitle,
          publishedAt: video.snippet.publishedAt,
          viewCount: parseInt(details.statistics.viewCount || '0'),
          duration: this.parseDurationToSeconds(details.contentDetails.duration),
          subscriberCount: channel ? parseInt(channel.statistics.subscriberCount || '0') : 0,
          priority: 0,
          // 추가 데이터
          likeCount: details.statistics.likeCount || 'N/A',
          commentCount: details.statistics.commentCount || 'N/A'
        } as PrioritizedVideo & { likeCount: string; commentCount: string };

        // 우선순위 점수 계산
        prioritizedVideo.priority = this.calculatePriority(prioritizedVideo);
        
        // 기본 필터링 조건
        if (this.passesBasicFilters(prioritizedVideo)) {
          prioritizedVideos.push(prioritizedVideo);
        }
      }

      // 5. 우선순위 순으로 정렬 후 상위 N개 반환
      const sortedVideos = prioritizedVideos
        .sort((a, b) => b.priority - a.priority)
        .slice(0, maxResults);

      console.log(`✅ 우선순위 분석 완료: ${sortedVideos.length}개 동영상 선별`);
      return sortedVideos;

    } catch (error) {
      console.error('❌ 우선순위 기반 검색 실패:', error);
      throw error;
    }
  }

  // 필터가 적용된 검색
  private async searchVideosWithFilters(keyword: string, maxResults: number): Promise<YouTubeVideoItem[]> {
    const encodedKeyword = encodeURIComponent(keyword);

    const url = `https://www.googleapis.com/youtube/v3/search?` +
      `part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}` +
      `&order=relevance&videoDuration=medium&videoCaption=any`;

    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`YouTube API 검색 실패: ${response.status}`);
    }

    const data: YouTubeSearchResponse = await response.json();
    return data.items;
  }

  // 여러 동영상의 상세 정보를 배치로 가져오기
  private async getMultipleVideoDetails(videoIds: string[]): Promise<YouTubeVideoDetails[]> {
    if (videoIds.length === 0) return [];

    const batchSize = 50; // YouTube API 제한
    const results: YouTubeVideoDetails[] = [];

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/videos?` +
        `part=statistics,contentDetails,snippet&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // 여러 채널의 상세 정보를 배치로 가져오기
  private async getMultipleChannelDetails(channelIds: string[]): Promise<YouTubeChannelDetails[]> {
    if (channelIds.length === 0) return [];

    const batchSize = 50;
    const results: YouTubeChannelDetails[] = [];

    for (let i = 0; i < channelIds.length; i += batchSize) {
      const batch = channelIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/channels?` +
        `part=statistics&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // 우선순위 점수 계산 (블로그 작성 참고용 콘텐츠 선별)
  private calculatePriority(video: PrioritizedVideo): number {
    let score = 0;

    // 1. 조회수 점수 (35%) - 많은 사람이 본 = 유용한 정보일 가능성
    if (video.viewCount > 1000000) score += 35;
    else if (video.viewCount > 500000) score += 30;
    else if (video.viewCount > 100000) score += 25;
    else if (video.viewCount > 50000) score += 20;
    else if (video.viewCount > 10000) score += 15;
    else if (video.viewCount > 1000) score += 10;

    // 2. 영상 길이 점수 (30%) - 적절한 길이 = 충분한 정보량
    if (video.duration >= 600 && video.duration <= 1200) score += 30; // 10-20분 (최적)
    else if (video.duration >= 300 && video.duration <= 1800) score += 25; // 5-30분
    else if (video.duration >= 180 && video.duration <= 1800) score += 20; // 3-30분
    else if (video.duration >= 120 && video.duration <= 1800) score += 15; // 2-30분

    // 3. 채널 신뢰성 점수 (25%) - 전문성과 신뢰도
    if (video.subscriberCount && video.subscriberCount > 1000000) score += 25;
    else if (video.subscriberCount && video.subscriberCount > 500000) score += 22;
    else if (video.subscriberCount && video.subscriberCount > 100000) score += 18;
    else if (video.subscriberCount && video.subscriberCount > 50000) score += 15;
    else if (video.subscriberCount && video.subscriberCount > 10000) score += 12;
    else if (video.subscriberCount && video.subscriberCount > 1000) score += 8;

    // 4. 업로드 날짜 점수 (10%) - 너무 오래되지 않은 정보 선호하되 큰 비중 X
    const daysSince = (Date.now() - new Date(video.publishedAt).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 365) score += 10;        // 1년 이내
    else if (daysSince < 365 * 2) score += 8; // 2년 이내
    else if (daysSince < 365 * 3) score += 6; // 3년 이내
    else if (daysSince < 365 * 5) score += 4; // 5년 이내
    else score += 2; // 5년 이상도 좋은 정보일 수 있음

    return score;
  }

  // 기본 필터링 조건
  private passesBasicFilters(video: PrioritizedVideo): boolean {
    // 최소 조건들
    if (video.viewCount < 100) return false; // 최소 조회수
    if (video.duration < 60) return false;   // 최소 1분
    if (video.duration > 1800) return false; // 최대 30분
    

    return true;
  }

  // ISO 8601 duration을 초로 변환
  private parseDurationToSeconds(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    return hours * 3600 + minutes * 60 + seconds;
  }


  // Google 차단 감지 함수
  private isGoogleBlocked(message: string): boolean {
    const blockedKeywords = [
      'automated queries',
      'Sorry...',
      'We\'re sorry',
      'protect our users',
      "can't process your request",
      'network may be sending',
      'verdana, arial, sans-serif',
      'GoogleSorry',
      'Google Help for more information',
      'Google Home'
    ];
    
    return blockedKeywords.some(keyword => 
      message.toLowerCase().includes(keyword.toLowerCase())
    );
  }

  // 대기 시간 계산 (에러 횟수에 따라 지수적 증가)
  private calculateDelay(): number {
    if (this.consecutiveErrors === 0) {
      return this.subtitleDelayMs; // 기본 5초
    }
    
    // 지수적 백오프: 5초 -> 10초 -> 20초 -> 40초 -> 60초(최대) + 랜덤 지터
    const baseDelay = this.subtitleDelayMs * Math.pow(2, this.consecutiveErrors);
    const jitter = Math.random() * 2000; // 0~2초 랜덤 추가
    const delayWithJitter = baseDelay + jitter;
    return Math.min(delayWithJitter, this.maxDelayMs);
  }

  // 요청 전 대기 처리
  private async waitBeforeRequest(): Promise<void> {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastSubtitleRequest;
    const requiredDelay = this.calculateDelay();
    
    if (timeSinceLastRequest < requiredDelay) {
      const waitTime = requiredDelay - timeSinceLastRequest;
      console.log(`⏳ Google 차단 방지를 위해 ${Math.round(waitTime / 1000)}초 대기... (에러 횟수: ${this.consecutiveErrors})`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    this.lastSubtitleRequest = Date.now();
  }

  // IPC를 통한 자막 추출 (메인 프로세스에서 실행)
  private async fetchSubtitleText(videoId: string, language?: string): Promise<string> {
    // 요청 전 대기 처리
    await this.waitBeforeRequest();
    
    try {
      console.log(`🔍 [렌더러] 자막 추출 요청: ${videoId} (언어: ${language || 'ko'})`);
      
      // 메인 프로세스로 자막 추출 요청
      const result = await (window as any).electronAPI.extractYouTubeSubtitles(videoId, language || 'ko');
      
      if (result.success && result.data) {
        console.log(`✅ [렌더러] 자막 추출 성공: ${result.data.length}자`);
        this.consecutiveErrors = 0; // 성공 시 에러 카운터 리셋
        return result.data.text;
      } else {
        // 실패 메시지에서 Google 차단 감지
        if (this.isGoogleBlocked(result.message || '')) {
          this.consecutiveErrors++;
          console.error(`❌ Google 차단 감지! 에러 횟수: ${this.consecutiveErrors}, 다음 대기 시간: ${Math.round(this.calculateDelay() / 1000)}초`);
          throw new Error(`Google에서 자동화 요청을 차단했습니다. 잠시 후 다시 시도해주세요.`);
        }
        
        console.error(`❌ [렌더러] 자막 추출 실패: ${result.message}`);
        return '';
      }

    } catch (error) {
      // Google 차단 예외가 아닌 일반 오류인 경우만 로그
      if (!(error instanceof Error && this.isGoogleBlocked(error.message))) {
        console.error(`❌ [렌더러] 자막 추출 시스템 오류 (${videoId}):`, error);
      }
      throw error; // 에러를 다시 던져서 상위에서 처리할 수 있도록
    }
  }



  // 간단한 자막 추출 (300자 이상만 통과) - 재시도 로직 적용
  async extractSubtitlesSimple(videoId: string, maxRetries: number = 3): Promise<SubtitleTrack[]> {
    let retryCount = 0;
    
    while (retryCount <= maxRetries) {
      try {
        console.log(`🎬 extractSubtitlesSimple 시작: ${videoId} (시도 ${retryCount + 1}/${maxRetries + 1})`);
        
        // 자막 추출 시도 (대기 시간 포함)
        await this.waitBeforeRequest();
        const result = await (window as any).electronAPI.extractYouTubeSubtitles(videoId, 'ko');
        
        if (result.success && result.data && result.data.text) {
          console.log(`✅ IPC 자막 추출 성공: ${result.data.language} ${result.data.length}자`);
          this.consecutiveErrors = 0; // 성공 시 에러 카운터 리셋
          return [{
            language: result.data.language,
            text: result.data.text,
            isAutoGenerated: result.data.isAutoGenerated || true
          }];
        } else {
          // Google 차단 감지
          if (this.isGoogleBlocked(result.message || '')) {
            this.consecutiveErrors++;
            const waitTime = this.calculateDelay();
            console.warn(`⚠️ Google 차단 감지 (${retryCount + 1}/${maxRetries + 1}): ${Math.round(waitTime / 1000)}초 후 재시도...`);
            
            if (retryCount < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, waitTime));
              retryCount++;
              continue;
            } else {
              console.error(`❌ 최대 재시도 횟수 초과. Google 차단으로 인해 자막 추출 실패: ${videoId}`);
              return [];
            }
          } else {
            console.warn(`⚠️ IPC 자막 추출 실패: ${result.message}`);
            return [];
          }
        }

      } catch (error) {
        // Google 차단 에러인 경우
        if (error instanceof Error && this.isGoogleBlocked(error.message)) {
          this.consecutiveErrors++;
          const waitTime = this.calculateDelay();
          console.warn(`⚠️ Google 차단 예외 감지 (${retryCount + 1}/${maxRetries + 1}): ${Math.round(waitTime / 1000)}초 후 재시도...`);
          
          if (retryCount < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, waitTime));
            retryCount++;
            continue;
          } else {
            console.error(`❌ 최대 재시도 횟수 초과. Google 차단으로 인해 자막 추출 완전 실패: ${videoId}`);
            return [];
          }
        } else {
          // 일반적인 에러
          console.error(`💥 extractSubtitlesSimple 시스템 오류: ${videoId}`, error);
          return [];
        }
      }
    }
    
    return [];
  }
  
  // 자막 추출 상태 리셋 (수동 리셋용)
  resetSubtitleState(): void {
    this.consecutiveErrors = 0;
    this.subtitleDelayMs = 3000;
    console.log('🔄 자막 추출 상태 리셋 완료');
  }
  
  // 현재 자막 추출 상태 정보 반환
  getSubtitleState(): { consecutiveErrors: number; currentDelay: number; maxDelay: number } {
    return {
      consecutiveErrors: this.consecutiveErrors,
      currentDelay: this.calculateDelay(),
      maxDelay: this.maxDelayMs
    };
  }
}

// 싱글톤 인스턴스
export const youtubeAPI = new YouTubeAPI();